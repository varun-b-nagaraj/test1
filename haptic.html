<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Xbox Haptics</title>
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: #1a1a1a;
    color: #e0e0e0;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .container {
    background: #2a2a2a;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    padding: 40px;
    width: 500px;
    max-width: 90vw;
    border: 1px solid #3a3a3a;
  }
  
  .title {
    text-align: center;
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 30px;
    color: #f0f0f0;
  }
  
  .status {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 30px;
    padding: 16px;
    background: #333;
    border-radius: 8px;
  }
  
  .status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #555;
    transition: all 0.3s ease;
  }
  
  .status-dot.connected { background: #28a745; }
  .status-dot.no-haptics { background: #ffc107; }
  
  .status-text {
    font-size: 14px;
    color: #ccc;
  }
  
  .controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-bottom: 30px;
  }
  
  .control {
    text-align: center;
  }
  
  .control-label {
    font-size: 14px;
    color: #aaa;
    margin-bottom: 8px;
    font-weight: 500;
  }
  
  .control-value {
    font-size: 32px;
    font-weight: 700;
    color: #f0f0f0;
    margin-bottom: 4px;
  }
  
  .control-unit {
    font-size: 12px;
    color: #888;
    margin-bottom: 16px;
  }
  
  .control-hint {
    font-size: 11px;
    color: #888;
    padding: 4px 8px;
    background: #333;
    border-radius: 4px;
    display: inline-block;
  }
  
  .buttons {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
  }
  
  .btn {
    padding: 12px 20px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #333;
    color: #e0e0e0;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .btn:hover {
    background: #3a3a3a;
    border-color: #555;
  }
  
  .btn:active {
    transform: scale(0.98);
  }
  
  .btn-primary {
    background: #007bff;
    color: white;
    border-color: #007bff;
  }
  
  .btn-primary:hover {
    background: #0056b3;
    border-color: #0056b3;
  }
  
  .btn-danger {
    background: #dc3545;
    color: white;
    border-color: #dc3545;
  }
  
  .btn-danger:hover {
    background: #c82333;
    border-color: #c82333;
  }
  
  .instructions {
    font-size: 12px;
    color: #aaa;
    text-align: center;
    line-height: 1.4;
  }
  
  .key {
    background: #444;
    padding: 2px 6px;
    border-radius: 3px;
    font-weight: 600;
    font-size: 11px;
    color: #ccc;
  }
  
  .running {
    border: 2px solid #28a745;
  }
  
  .debug {
    margin-top: 16px;
    padding: 8px;
    background: #333;
    border-radius: 4px;
    font-family: monospace;
    font-size: 11px;
    color: #aaa;
    text-align: center;
  }
</style>
</head>
<body>
<div class="container" id="container">
  <h1 class="title">Xbox Haptics</h1>
  
  <div class="status">
    <div class="status-dot" id="statusDot"></div>
    <div class="status-text" id="statusText">Connect controller and press any button</div>
  </div>
  
  <div class="controls">
    <div class="control">
      <div class="control-label">Intensity</div>
      <div class="control-value" id="intensityValue">60</div>
      <div class="control-unit">percent</div>
      <div class="control-hint">D-pad ↑↓</div>
    </div>
    
    <div class="control">
      <div class="control-label">Frequency</div>
      <div class="control-value" id="frequencyValue">3.2</div>
      <div class="control-unit" id="frequencyUnit">Hz</div>
      <div class="control-hint">D-pad ←→</div>
    </div>
  </div>
  
  <div class="buttons">
    <button class="btn" id="detectBtn">Detect</button>
    <button class="btn btn-primary" id="toggleBtn">Start</button>
  </div>
  
  <div class="instructions">
    Press <span class="key">B</span> to toggle • 
    <span class="key">D-pad ↑↓</span> intensity • 
    <span class="key">D-pad ←→</span> frequency •
    <span class="key">Y</span> power mode
  </div>
  
  <div class="debug" id="debug">Ready</div>
</div>

<script>
(() => {
  const elements = {
    container: document.getElementById('container'),
    statusDot: document.getElementById('statusDot'),
    statusText: document.getElementById('statusText'),
    intensityValue: document.getElementById('intensityValue'),
    frequencyValue: document.getElementById('frequencyValue'),
    frequencyUnit: document.getElementById('frequencyUnit'),
    detectBtn: document.getElementById('detectBtn'),
    toggleBtn: document.getElementById('toggleBtn'),
    debug: document.getElementById('debug')
  };

  const state = {
    controllerIndex: null,
    isRunning: false,
    animationId: null,
    intensity: 75.0, // Start higher for more power
    frequency: 20, // Start at a good middle frequency
    lastButtons: null,
    lastInputTime: 0,
    powerMode: 'normal' // normal, boost, max
  };

  // More aggressive frequency scaling with wider range
  function posToHz(pos) {
    if (pos >= 100) return Infinity;
    if (pos <= 0) return 0;
    
    // Exponential curve for more power at high end, precision at low end
    const norm = pos / 100;
    if (norm < 0.3) {
      // Fine control for low frequencies (0-5Hz)
      return norm * 16.67; // 0-5Hz in first 30%
    } else {
      // More aggressive scaling for higher frequencies (5-100Hz)
      const highNorm = (norm - 0.3) / 0.7;
      return 5 + Math.pow(highNorm, 1.5) * 95; // 5-100Hz in remaining 70%
    }
  }

  function getGamepads() {
    return navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
  }

  function hasHaptics(gp) {
    return gp?.vibrationActuator && typeof gp.vibrationActuator.playEffect === 'function';
  }

  function findController() {
    const pads = getGamepads();
    for (let i = 0; i < pads.length; i++) {
      const gp = pads[i];
      if (gp?.connected && gp.mapping === 'standard' && hasHaptics(gp)) {
        return { gamepad: gp, index: i, hasHaptics: true };
      }
    }
    for (let i = 0; i < pads.length; i++) {
      const gp = pads[i];
      if (gp?.connected && hasHaptics(gp)) {
        return { gamepad: gp, index: i, hasHaptics: true };
      }
    }
    for (let i = 0; i < pads.length; i++) {
      const gp = pads[i];
      if (gp?.connected) {
        return { gamepad: gp, index: i, hasHaptics: false };
      }
    }
    return null;
  }

  function updateStatus() {
    const found = findController();
    
    if (!found) {
      elements.statusDot.className = 'status-dot';
      elements.statusText.textContent = 'Connect controller and press any button';
    } else if (found.hasHaptics) {
      elements.statusDot.className = 'status-dot connected';
      elements.statusText.textContent = 'Controller connected - haptics ready';
    } else {
      elements.statusDot.className = 'status-dot no-haptics';
      elements.statusText.textContent = 'Controller connected - no haptics';
    }
  }

  function updateDisplay() {
    elements.intensityValue.textContent = state.intensity.toFixed(1);
    
    const hz = posToHz(state.frequency);
    if (hz === Infinity) {
      elements.frequencyValue.textContent = '∞';
      elements.frequencyUnit.textContent = 'constant';
    } else if (hz === 0) {
      elements.frequencyValue.textContent = '0';
      elements.frequencyUnit.textContent = 'off';
    } else {
      elements.frequencyValue.textContent = hz.toFixed(1);
      elements.frequencyUnit.textContent = 'Hz';
    }
    
    // Update button text and style
    if (state.isRunning) {
      elements.toggleBtn.textContent = 'Stop';
      elements.toggleBtn.className = 'btn btn-danger';
    } else {
      elements.toggleBtn.textContent = 'Start';
      elements.toggleBtn.className = 'btn btn-primary';
    }
  }

  function readButtons(gp) {
    if (!gp || !gp.buttons) return null;
    
    const buttons = gp.buttons;
    return {
      B: buttons[1]?.pressed || false,
      Y: buttons[3]?.pressed || false, // Add Y button for power modes
      DPAD_UP: buttons[12]?.pressed || false,
      DPAD_DOWN: buttons[13]?.pressed || false,
      DPAD_LEFT: buttons[14]?.pressed || false,
      DPAD_RIGHT: buttons[15]?.pressed || false
    };
  }

  function sendHaptics(intensity, duration) {
    const pads = getGamepads();
    const gp = pads[state.controllerIndex];
    if (!gp?.vibrationActuator) return;
    
    // MAXIMUM POWER: Ensure we're using full range and boost intensity
    let strength = intensity / 100;
    
    // Power boost modes for extra intensity
    if (state.powerMode === 'boost') {
      strength = Math.min(1.0, strength * 1.15); // 15% boost
    } else if (state.powerMode === 'max') {
      strength = 1.0; // Always maximum when in max mode
    }
    
    // Use both strong and weak motors at full capacity
    gp.vibrationActuator.playEffect('dual-rumble', {
      startDelay: 0,
      duration: Math.max(25, duration), // Longer duration for more impact
      strongMagnitude: strength,
      weakMagnitude: strength * 0.85 // Slightly different for richer feel
    }).catch(() => {});
  }

  function stopHaptics() {
    const pads = getGamepads();
    const gp = pads[state.controllerIndex];
    if (!gp?.vibrationActuator) return;
    
    if (typeof gp.vibrationActuator.reset === 'function') {
      gp.vibrationActuator.reset().catch(() => {});
    } else {
      sendHaptics(0, 50);
    }
  }

  function hapticsLoop(timestamp) {
    if (!state.isRunning) {
      state.animationId = null;
      return;
    }
    
    const pads = getGamepads();
    const gp = pads[state.controllerIndex];
    if (!gp?.connected || !gp.vibrationActuator) {
      stop();
      updateStatus();
      return;
    }
    
    const hz = posToHz(state.frequency);
    const time = timestamp / 1000;
    let amplitude;
    
    if (hz === Infinity) {
      amplitude = state.intensity; // Full constant power
    } else if (hz <= 0) {
      amplitude = 0;
    } else {
      // Enhanced sine wave with better contrast
      const sine = Math.sin(2 * Math.PI * hz * time);
      const normalizedSine = (sine + 1) / 2; // 0 to 1
      
      // More aggressive modulation for better feel
      const floor = 0.02; // Very low floor for maximum contrast
      const modulation = Math.max(floor, Math.pow(normalizedSine, 0.7)); // Slight curve for more punch
      
      amplitude = state.intensity * modulation;
    }
    
    // Send haptics more frequently for smoother feel
    sendHaptics(amplitude, 20);
    state.animationId = requestAnimationFrame(hapticsLoop);
  }

  function start() {
    const found = findController();
    if (!found || !found.hasHaptics) {
      updateStatus();
      alert('No controller with haptics found');
      return;
    }
    
    state.controllerIndex = found.index;
    state.isRunning = true;
    elements.container.classList.add('running');
    updateDisplay();
    
    if (!state.animationId) {
      state.animationId = requestAnimationFrame(hapticsLoop);
    }
  }

  function stop() {
    state.isRunning = false;
    elements.container.classList.remove('running');
    updateDisplay();
    
    if (state.animationId) {
      cancelAnimationFrame(state.animationId);
      state.animationId = null;
    }
    
    stopHaptics();
  }

  function toggle() {
    if (state.isRunning) {
      stop();
    } else {
      start();
    }
  }

  function pollController() {
    const found = findController();
    if (!found) {
      updateStatus();
      state.lastButtons = null;
      elements.debug.textContent = 'No controller';
      return;
    }
    
    updateStatus();
    
    const buttons = readButtons(found.gamepad);
    if (!buttons) return;
    
    const prev = state.lastButtons;
    
    // B button toggle (only on press, not hold)
    if (buttons.B && !(prev?.B)) {
      toggle();
    }
        
    // ULTRA RESPONSIVE CONTROLS with power scaling
    const now = performance.now();
    const dt = Math.min((now - state.lastInputTime) / 1000, 0.05); // Cap for stability
    state.lastInputTime = now;
    
    // Intensity: D-pad up/down - MUCH more responsive with acceleration
    const intensityHeld = buttons.DPAD_UP || buttons.DPAD_DOWN;
    const intensitySpeed = intensityHeld ? 200 : 120; // Faster when actively adjusting
    
    if (buttons.DPAD_UP) {
      state.intensity = Math.min(100, state.intensity + intensitySpeed * dt);
      updateDisplay();
    }
    if (buttons.DPAD_DOWN) {
      state.intensity = Math.max(0, state.intensity - intensitySpeed * dt);
      updateDisplay();
    }
    
    // Frequency: D-pad left/right - Precision at low end, speed at high end
    const currentHz = posToHz(state.frequency);
    const freqSpeed = currentHz < 10 ? 15 : 35; // Slower for precision, faster for power
    
    if (buttons.DPAD_RIGHT) {
      state.frequency = Math.min(100, state.frequency + freqSpeed * dt);
      updateDisplay();
    }
    if (buttons.DPAD_LEFT) {
      state.frequency = Math.max(0, state.frequency - freqSpeed * dt);
      updateDisplay();
    }
    
    // Cycle power modes with Y button (if available)
    if (buttons.Y && !(prev?.Y)) {
      if (state.powerMode === 'normal') state.powerMode = 'boost';
      else if (state.powerMode === 'boost') state.powerMode = 'max';
      else state.powerMode = 'normal';
      updateDisplay();
    }
    
    state.lastButtons = buttons;
    
    elements.debug.textContent = 
      `Power: ${state.powerMode.toUpperCase()} | ` +
      `Intensity: ${state.intensity.toFixed(1)}% | ` +
      `Frequency: ${elements.frequencyValue.textContent}${elements.frequencyUnit.textContent} | ` +
      `${state.isRunning ? 'Running' : 'Stopped'}`;
  }

  // Event listeners
  elements.detectBtn.addEventListener('click', updateStatus);
  elements.toggleBtn.addEventListener('click', toggle);

  window.addEventListener('gamepadconnected', updateStatus);
  window.addEventListener('gamepaddisconnected', () => {
    stop();
    updateStatus();
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) stop();
  });

  // Initialize
  updateDisplay();
  updateStatus();
  
  // Poll controller at 60fps
  setInterval(pollController, 16);
})();
</script>
</body>
</html>