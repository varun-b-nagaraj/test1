<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Xbox Haptics</title>
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: #1a1a1a;
    color: #e0e0e0;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .container {
    background: #2a2a2a;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    padding: 40px;
    width: 500px;
    max-width: 90vw;
    border: 1px solid #3a3a3a;
  }
  
  .title {
    text-align: center;
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 30px;
    color: #f0f0f0;
  }
  
  .status {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 30px;
    padding: 16px;
    background: #333;
    border-radius: 8px;
  }
  
  .status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #555;
    transition: all 0.3s ease;
  }
  
  .status-dot.connected { background: #28a745; }
  .status-dot.no-haptics { background: #ffc107; }
  
  .status-text {
    font-size: 14px;
    color: #ccc;
  }
  
  .controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-bottom: 30px;
  }
  
  .control {
    text-align: center;
  }
  
  .control-label {
    font-size: 14px;
    color: #aaa;
    margin-bottom: 8px;
    font-weight: 500;
  }
  
  .control-value {
    font-size: 32px;
    font-weight: 700;
    color: #f0f0f0;
    margin-bottom: 4px;
  }
  
  .control-unit {
    font-size: 12px;
    color: #888;
    margin-bottom: 16px;
  }
  
  .control-hint {
    font-size: 11px;
    color: #888;
    padding: 4px 8px;
    background: #333;
    border-radius: 4px;
    display: inline-block;
  }
  
  .frequency-mode {
    background: #444;
    border: 2px solid #555;
    border-radius: 6px;
    padding: 8px;
    margin-bottom: 8px;
    transition: all 0.2s ease;
  }
  
  .frequency-mode.active {
    border-color: #007bff;
    background: #1a3a5c;
  }
  
  .mode-name {
    font-weight: 600;
    color: #f0f0f0;
    font-size: 14px;
  }
  
  .mode-desc {
    font-size: 11px;
    color: #aaa;
    margin-top: 2px;
  }
  
  .buttons {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
  }
  
  .btn {
    padding: 12px 20px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #333;
    color: #e0e0e0;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .btn:hover {
    background: #3a3a3a;
    border-color: #555;
  }
  
  .btn:active {
    transform: scale(0.98);
  }
  
  .btn-primary {
    background: #007bff;
    color: white;
    border-color: #007bff;
  }
  
  .btn-primary:hover {
    background: #0056b3;
    border-color: #0056b3;
  }
  
  .btn-danger {
    background: #dc3545;
    color: white;
    border-color: #dc3545;
  }
  
  .btn-danger:hover {
    background: #c82333;
    border-color: #c82333;
  }
  
  .instructions {
    font-size: 12px;
    color: #aaa;
    text-align: center;
    line-height: 1.4;
  }
  
  .key {
    background: #444;
    padding: 2px 6px;
    border-radius: 3px;
    font-weight: 600;
    font-size: 11px;
    color: #ccc;
  }
  
  .running {
    border: 2px solid #28a745;
  }
  
  .debug {
    margin-top: 16px;
    padding: 8px;
    background: #333;
    border-radius: 4px;
    font-family: monospace;
    font-size: 11px;
    color: #aaa;
    text-align: center;
  }
  
  .power-indicator {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: 600;
    margin-left: 8px;
  }
  
  .power-normal { background: #28a745; color: white; }
  .power-boost { background: #ffc107; color: black; }
  .power-max { background: #dc3545; color: white; }
  .power-overdrive { background: #ff1744; color: white; animation: pulse 0.8s infinite; }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
</style>
</head>
<body>
<div class="container" id="container">
  <h1 class="title">Xbox Haptics</h1>
  
  <div class="status">
    <div class="status-dot" id="statusDot"></div>
    <div class="status-text" id="statusText">Connect controller and press any button</div>
  </div>
  
  <div class="controls">
    <div class="control">
      <div class="control-label">Intensity</div>
      <div class="control-value" id="intensityValue">85</div>
      <div class="control-unit">percent</div>
      <div class="control-hint">D-pad ↑↓</div>
    </div>
    
    <div class="control">
      <div class="control-label">
        Frequency Mode
        <span class="power-indicator" id="powerIndicator">NORMAL</span>
      </div>
      <div class="frequency-mode" id="freqModeDisplay">
        <div class="mode-name" id="modeName">Thunder</div>
        <div class="mode-desc" id="modeDesc">12Hz - Deep powerful pulses</div>
      </div>
      <div class="control-hint">D-pad ←→ to cycle</div>
    </div>
  </div>
  
  <div class="buttons">
    <button class="btn" id="detectBtn">Detect</button>
    <button class="btn btn-primary" id="toggleBtn">Start</button>
  </div>
  
  <div class="instructions">
    Press <span class="key">B</span> to toggle • 
    <span class="key">D-pad ↑↓</span> intensity • 
    <span class="key">D-pad ←→</span> frequency mode •
    <span class="key">Y</span> power boost
  </div>
  
  <div class="debug" id="debug">Ready</div>
</div>

<script>
(() => {
  const elements = {
    container: document.getElementById('container'),
    statusDot: document.getElementById('statusDot'),
    statusText: document.getElementById('statusText'),
    intensityValue: document.getElementById('intensityValue'),
    freqModeDisplay: document.getElementById('freqModeDisplay'),
    modeName: document.getElementById('modeName'),
    modeDesc: document.getElementById('modeDesc'),
    powerIndicator: document.getElementById('powerIndicator'),
    detectBtn: document.getElementById('detectBtn'),
    toggleBtn: document.getElementById('toggleBtn'),
    debug: document.getElementById('debug')
  };

  // POWERFUL FREQUENCY MODES - Each designed for maximum impact
  const frequencyModes = [
    { name: 'Gentle', hz: 8, desc: '8Hz - Smooth steady rhythm', powerMult: 1.0 },
    { name: 'Thunder', hz: 12, desc: '12Hz - Deep powerful pulses', powerMult: 1.1 },
    { name: 'Engine', hz: 18, desc: '18Hz - Motor-like rumble', powerMult: 1.15 },
    { name: 'Rapid', hz: 28, desc: '28Hz - Fast intense beats', powerMult: 1.2 },
    { name: 'Buzz', hz: 45, desc: '45Hz - High energy buzz', powerMult: 1.25 },
    { name: 'Fury', hz: 65, desc: '65Hz - Aggressive vibration', powerMult: 1.3 },
    { name: 'Lightning', hz: 85, desc: '85Hz - Ultra-fast pulses', powerMult: 1.35 },
    { name: 'Insane', hz: 120, desc: '120Hz - Maximum frequency', powerMult: 1.4 },
    { name: 'Constant', hz: Infinity, desc: 'Pure constant power', powerMult: 1.5 }
  ];

  const state = {
    controllerIndex: null,
    isRunning: false,
    animationId: null,
    intensity: 85.0, // Start high for immediate power
    frequencyModeIndex: 1, // Start with Thunder mode
    lastButtons: null,
    lastInputTime: 0,
    powerMode: 'normal', // normal, boost, max, overdrive
    intensityHoldTime: { up: 0, down: 0 } // Track button hold duration
  };

  function getGamepads() {
    return navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
  }

  function hasHaptics(gp) {
    return gp?.vibrationActuator && typeof gp.vibrationActuator.playEffect === 'function';
  }

  function findController() {
    const pads = getGamepads();
    for (let i = 0; i < pads.length; i++) {
      const gp = pads[i];
      if (gp?.connected && gp.mapping === 'standard' && hasHaptics(gp)) {
        return { gamepad: gp, index: i, hasHaptics: true };
      }
    }
    for (let i = 0; i < pads.length; i++) {
      const gp = pads[i];
      if (gp?.connected && hasHaptics(gp)) {
        return { gamepad: gp, index: i, hasHaptics: true };
      }
    }
    for (let i = 0; i < pads.length; i++) {
      const gp = pads[i];
      if (gp?.connected) {
        return { gamepad: gp, index: i, hasHaptics: false };
      }
    }
    return null;
  }

  function updateStatus() {
    const found = findController();
    
    if (!found) {
      elements.statusDot.className = 'status-dot';
      elements.statusText.textContent = 'Connect controller and press any button';
    } else if (found.hasHaptics) {
      elements.statusDot.className = 'status-dot connected';
      elements.statusText.textContent = 'Controller connected - haptics ready';
    } else {
      elements.statusDot.className = 'status-dot no-haptics';
      elements.statusText.textContent = 'Controller connected - no haptics';
    }
  }

  function updateDisplay() {
    elements.intensityValue.textContent = state.intensity.toFixed(1);
    
    // Update frequency mode display
    const mode = frequencyModes[state.frequencyModeIndex];
    elements.modeName.textContent = mode.name;
    elements.modeDesc.textContent = mode.desc;
    elements.freqModeDisplay.className = 'frequency-mode active';
    
    // Update power indicator
    const powerClasses = {
      normal: 'power-normal',
      boost: 'power-boost', 
      max: 'power-max',
      overdrive: 'power-overdrive'
    };
    elements.powerIndicator.className = `power-indicator ${powerClasses[state.powerMode]}`;
    elements.powerIndicator.textContent = state.powerMode.toUpperCase();
    
    // Update button text and style
    if (state.isRunning) {
      elements.toggleBtn.textContent = 'Stop';
      elements.toggleBtn.className = 'btn btn-danger';
    } else {
      elements.toggleBtn.textContent = 'Start';
      elements.toggleBtn.className = 'btn btn-primary';
    }
  }

  function readButtons(gp) {
    if (!gp || !gp.buttons) return null;
    
    const buttons = gp.buttons;
    return {
      B: buttons[1]?.pressed || false,
      Y: buttons[3]?.pressed || false,
      DPAD_UP: buttons[12]?.pressed || false,
      DPAD_DOWN: buttons[13]?.pressed || false,
      DPAD_LEFT: buttons[14]?.pressed || false,
      DPAD_RIGHT: buttons[15]?.pressed || false
    };
  }

  function sendHaptics(intensity, duration) {
    const pads = getGamepads();
    const gp = pads[state.controllerIndex];
    if (!gp?.vibrationActuator) return;
    
    // MAXIMUM POWER CALCULATIONS
    let strength = intensity / 100;
    const mode = frequencyModes[state.frequencyModeIndex];
    
    // Apply mode-specific power multiplier
    strength *= mode.powerMult;
    
    // Apply global power boost modes
    switch (state.powerMode) {
      case 'boost':
        strength *= 1.2; // 20% boost
        break;
      case 'max':
        strength *= 1.4; // 40% boost
        break;
      case 'overdrive':
        strength *= 1.6; // 60% boost - MAXIMUM POWER
        break;
    }
    
    // Ensure we never exceed 1.0 but get as close as possible
    strength = Math.min(1.0, strength);
    
    // Use both motors with slightly different strengths for richer haptics
    const strongMag = strength;
    const weakMag = strength * 0.92; // Slightly different for texture
    
    gp.vibrationActuator.playEffect('dual-rumble', {
      startDelay: 0,
      duration: Math.max(15, duration), // Longer for more impact
      strongMagnitude: strongMag,
      weakMagnitude: weakMag
    }).catch(() => {});
  }

  function stopHaptics() {
    const pads = getGamepads();
    const gp = pads[state.controllerIndex];
    if (!gp?.vibrationActuator) return;
    
    if (typeof gp.vibrationActuator.reset === 'function') {
      gp.vibrationActuator.reset().catch(() => {});
    } else {
      sendHaptics(0, 50);
    }
  }

  function hapticsLoop(timestamp) {
    if (!state.isRunning) {
      state.animationId = null;
      return;
    }
    
    const pads = getGamepads();
    const gp = pads[state.controllerIndex];
    if (!gp?.connected || !gp.vibrationActuator) {
      stop();
      updateStatus();
      return;
    }
    
    const mode = frequencyModes[state.frequencyModeIndex];
    const hz = mode.hz;
    const time = timestamp / 1000;
    let amplitude;
    
    if (hz === Infinity) {
      // Constant maximum power
      amplitude = state.intensity;
    } else {
      // Enhanced sine wave modulation with aggressive curves
      const sine = Math.sin(2 * Math.PI * hz * time);
      const normalizedSine = (sine + 1) / 2; // 0 to 1
      
      // Ultra-aggressive modulation for maximum power feel
      const floor = 0.01; // Nearly zero floor for maximum contrast
      const curve = Math.pow(normalizedSine, 0.6); // Curve for more punch
      const modulation = Math.max(floor, curve);
      
      amplitude = state.intensity * modulation;
    }
    
    // Send haptics at high frequency for smooth powerful feel
    sendHaptics(amplitude, 12);
    state.animationId = requestAnimationFrame(hapticsLoop);
  }

  function start() {
    const found = findController();
    if (!found || !found.hasHaptics) {
      updateStatus();
      alert('No controller with haptics found');
      return;
    }
    
    state.controllerIndex = found.index;
    state.isRunning = true;
    elements.container.classList.add('running');
    updateDisplay();
    
    if (!state.animationId) {
      state.animationId = requestAnimationFrame(hapticsLoop);
    }
  }

  function stop() {
    state.isRunning = false;
    elements.container.classList.remove('running');
    updateDisplay();
    
    if (state.animationId) {
      cancelAnimationFrame(state.animationId);
      state.animationId = null;
    }
    
    stopHaptics();
  }

  function toggle() {
    if (state.isRunning) {
      stop();
    } else {
      start();
    }
  }

  function pollController() {
    const found = findController();
    if (!found) {
      updateStatus();
      state.lastButtons = null;
      elements.debug.textContent = 'No controller';
      return;
    }
    
    updateStatus();
    
    const buttons = readButtons(found.gamepad);
    if (!buttons) return;
    
    const prev = state.lastButtons;
    
    // B button toggle
    if (buttons.B && !(prev?.B)) {
      toggle();
    }
        
    // SMOOTH INTENSITY CONTROLS with acceleration
    const now = performance.now();
    const dt = Math.min((now - state.lastInputTime) / 1000, 0.05);
    state.lastInputTime = now;
    
    // Track how long buttons have been held
    if (!state.intensityHoldTime) state.intensityHoldTime = { up: 0, down: 0 };
    
    // Intensity: D-pad up/down with smooth acceleration
    if (buttons.DPAD_UP) {
      if (!(prev?.DPAD_UP)) {
        // Just pressed - small initial step
        state.intensity = Math.min(100, state.intensity + 2);
        state.intensityHoldTime.up = 0;
      } else {
        // Held - accelerate over time
        state.intensityHoldTime.up += dt;
        const holdTime = state.intensityHoldTime.up;
        
        // Smooth acceleration curve: slow start, then faster
        let speed;
        if (holdTime < 0.3) {
          speed = 15; // Very slow for first 0.3 seconds
        } else if (holdTime < 0.8) {
          speed = 35; // Medium speed for next 0.5 seconds
        } else if (holdTime < 1.5) {
          speed = 70; // Faster after 0.8 seconds
        } else {
          speed = 120; // Maximum speed after 1.5 seconds
        }
        
        state.intensity = Math.min(100, state.intensity + speed * dt);
      }
      updateDisplay();
    } else {
      state.intensityHoldTime.up = 0;
    }
    
    if (buttons.DPAD_DOWN) {
      if (!(prev?.DPAD_DOWN)) {
        // Just pressed - small initial step
        state.intensity = Math.max(5, state.intensity - 2);
        state.intensityHoldTime.down = 0;
      } else {
        // Held - accelerate over time
        state.intensityHoldTime.down += dt;
        const holdTime = state.intensityHoldTime.down;
        
        // Same acceleration curve as up
        let speed;
        if (holdTime < 0.3) {
          speed = 15;
        } else if (holdTime < 0.8) {
          speed = 35;
        } else if (holdTime < 1.5) {
          speed = 70;
        } else {
          speed = 120;
        }
        
        state.intensity = Math.max(5, state.intensity - speed * dt);
      }
      updateDisplay();
    } else {
      state.intensityHoldTime.down = 0;
    }
    
    // Frequency mode cycling: D-pad left/right
    if (buttons.DPAD_RIGHT && !(prev?.DPAD_RIGHT)) {
      state.frequencyModeIndex = (state.frequencyModeIndex + 1) % frequencyModes.length;
      updateDisplay();
    }
    if (buttons.DPAD_LEFT && !(prev?.DPAD_LEFT)) {
      state.frequencyModeIndex = (state.frequencyModeIndex - 1 + frequencyModes.length) % frequencyModes.length;
      updateDisplay();
    }
    
    // Cycle power modes with Y button
    if (buttons.Y && !(prev?.Y)) {
      const modes = ['normal', 'boost', 'max', 'overdrive'];
      const currentIndex = modes.indexOf(state.powerMode);
      state.powerMode = modes[(currentIndex + 1) % modes.length];
      updateDisplay();
    }
    
    state.lastButtons = buttons;
    
    const mode = frequencyModes[state.frequencyModeIndex];
    elements.debug.textContent = 
      `${state.powerMode.toUpperCase()} | ` +
      `${state.intensity.toFixed(1)}% | ` +
      `${mode.name} (${mode.hz === Infinity ? '∞' : mode.hz}Hz) | ` +
      `${state.isRunning ? 'ACTIVE' : 'Stopped'}`;
  }

  // Event listeners
  elements.detectBtn.addEventListener('click', updateStatus);
  elements.toggleBtn.addEventListener('click', toggle);

  window.addEventListener('gamepadconnected', updateStatus);
  window.addEventListener('gamepaddisconnected', () => {
    stop();
    updateStatus();
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) stop();
  });

  // Initialize
  updateDisplay();
  updateStatus();
  
  // Poll controller at 60fps for maximum responsiveness
  setInterval(pollController, 16);
})();
</script>
</body>
</html>